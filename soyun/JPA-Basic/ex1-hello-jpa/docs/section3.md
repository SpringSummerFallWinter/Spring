# Section3. 영속성 관리

<br/>

## JPA에서 가장 중요한 2가지
- 객체와 관계형 데이터베이스 매핑하기(ORM)
- **영속성 컨텍스트**

<br/>

## 영속성 컨텍스트
- 엔티티를 영구 저장하는 환경
- 논리적인 개념으로 눈으로 볼 수늰 없음
- `EntityManager`를 통해 영속성 컨텍스트에 접근

### J2SE 환경
- 엔티티 매니저와 영속성 컨텍스트가 1:1

### J2EE, 스프링 프레임워크와 같은 환경
- 엔티티 매니저와 영속성 컨텍스트가 N:1
- 고객마다 엔티티 매니저가 존재하기 때문!

<br/>

## 엔티티의 생명주기
### 비영속
  - 아직 영속성 컨텍스트에 등록 X
  ```java
    // 비영속
    Member member = new Member();
    member.setId(101L);
    member.setName("HelloPSY");
   ```
### 영속
  - 영속성 컨텍스트에 의해 관리되는 상태
  ```java
    // 영속  
    em.persist(member);
   ```
### 준영속
  - 엔티티를 영속성 컨텍스트에서 분리(detach)한 상태
  - 영속성 컨텍스트의 기능 사용 불가
  ```java
    // 준영속
    em.detach(member);
   ```
### 삭제
  - 엔티티를 영속성 컨텍스트에서 삭제한 상태
  - 영속성 컨텍스트의 기능 사용 불가
  ```java
      // 삭제
      em.remove(member);
   ```

<br/>

## 영속성 컨텍스트의 이점

### 1차 캐시
- 엔티티가 영속성 컨텍스트에 올라가는 경우, 1차 캐시에 저장됨
- 다음에 조회할 때는 1차 캐시에서 조회
  - 복잡한 조회 로직이 아니라면 생각보다 1차 캐시의 성능 차이는 미미한 편
- 1차 캐시에 없는 엔티티를 조회하려는 경우, 먼저 DB에서 조회 후 1차 캐시에 올림

### 동일성 보장
- 영속성 컨텍스트에 올라간 특정 객체를 조회하는 경우, 몇 번을 조회하든지 같은 객체 반환 

### 트랜잭션을 지원하는 쓰기 지연
- `em.persist()`를 호출했다고 바로 SQL 쿼리 날아가지 않음
- 등록, 수정, 삭제 쿼리들을 **쓰기 지연 SQL 저장소**에 저장해두었다가 트랜잭션 commit 시 한 번에 DB로 쿼리 날림

### 변경 감지(Dirty Checking)
- 엔티티 스냅샷
  - 엔티티를 최초로 읽어왔을 때의 상태를 저장한 것
- 엔티티 스냅샷과 현재 엔티티의 상태를 비교
  - 엔티티에 변경이 일어났을 경우 update 쿼리를 생성함
  - Java의 Collection처럼 Collection 내부의 객체가 변경되어도 굳이 set 해줄 필요가 없음

### 지연 로딩
- 매우 중요하지만 아직 배우지는 않음

<br/>

## 플러시
- 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영
- 영속성 컨텍스트를 초기화하는 것은 아님!

### 플러시 발생
- 변경 감지
- 수정된 엔티티를 쓰기 지연 SQL 저장소에 등록
- **쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송**(등록, 수정, 삭제 쿼리)

### 플러시하는 방법
- 직접 호출
  - `em.flush()`
- 트랜잭션 커밋
- JPQL 쿼리 실행
  - 플러시 모드는 기본적으로 AUTO로 설정되어 있음
  - COMMIT으로 변경한다면, 커밋할 때만 플러시 됨
  - 되도록이면 AUTO를 사용하자...

<br/>
<br/>